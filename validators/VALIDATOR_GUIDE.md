# BuddAI Validator Guide

The Validator System is BuddAI's immune system‚Äîprotecting generated code from hardware damage, logic errors, and style violations. It runs automatically on every code block generated by the AI.

## üõ°Ô∏è Active Validators

### 1. ESP32 Hardware Safety (`ESP32Validator`)

Ensures code respects ESP32 architecture limitations.

- **‚ùå analogWrite:** ESP32 does not support Arduino's `analogWrite`. Auto-fixes to `ledcWrite`.
- **‚ùå 10-bit ADC:** Detects hardcoded `1023` or `1024` math. ESP32 is 12-bit (`4095`).
- **‚ùå ADC Resolution:** Ensures `analogReadResolution` matches expectations.

### 2. Motor Control Safety (`MotorValidator`)

Prevents H-Bridge shoot-through and ensures control logic exists.

- **‚ùå PWM Conflict:** Flags if a pin is used for both PWM (`ledcAttachPin`) and digital logic (`digitalWrite`).
- **‚ùå Missing Pins:** Checks for L298N definitions (`IN1`, `IN2`, `ENA`).
- **‚ùå No Direction:** Ensures `digitalWrite` sets direction before speed control.

### 3. Timing & Safety (`TimingValidator`)

Critical checks for non-blocking operations.

- **‚ùå Blocking Delays:** Flags `delay()` inside motor loops (causes loss of control).
- **‚ùå Missing Timeout:** Requires a safety timeout (e.g., 5000ms) to stop motors if signal is lost.
- **‚ùå Broken Debounce:** Detects type mismatches in time comparisons.
- **‚ùå Static Timers:** Fixes `static unsigned long timer = millis()` (which prevents resets).
- **‚ùå High-Freq Logging:** Warns about serial prints inside high-speed loops.

### 4. Forge Theory (`ForgeTheoryValidator`)

Enforces James's physics-based motion smoothing.

- **‚ùå Direct Control:** Flags raw `ledcWrite` or `servo.write` calls in motor contexts.
- **‚úÖ Exponential Decay:** Suggests `current += (target - current) * k` for fluid movement.

### 5. Servo & Combat Logic (`ServoValidator`)

Specific rules for weapon systems and actuators.

- **‚ùå Unsafe Weapons:** Requires a State Machine (`DISARMED`, `ARMED`, `FIRING`) for combat code.
- **‚ùå Missing Inputs:** Ensures Serial/Input handling exists to control the servo.

### 6. Arduino Compatibility (`ArduinoValidator`)

General Arduino ecosystem checks.

- **‚ùå Unnecessary Includes:** Removes unused `<Wire.h>`.
- **‚ùå Undefined Pins:** Detects variables used as pins that aren't defined.
- **‚ùå Missing Init:** Checks for `Serial.begin()` and `Wire.begin()`.

### 7. Memory Safety (`MemoryValidator`)

Prevents stack overflows and wasted RAM.

- **‚ùå Unused Variables:** Removes variables declared in `setup()` but never used.

### 8. Style & Modularity (`StyleValidator`)

Enforces the "James Gilbert" coding signature.

- **‚ùå Feature Bloat:** Removes unrequested buttons or inputs.
- **‚ùå Monolithic Loops:** Flags `loop()` functions longer than 10 lines (suggests modular functions).
- **‚ùå Naming:** Enforces `camelCase` for functions.
- **‚ùå Status LEDs:** Enforces blinking states over breathing/fading for status indicators.

### 9. Bluetooth (`BluetoothValidator`)

- **‚ùå Missing Init:** Ensures `BLEDevice::init()` is called if BLE libraries are included.

---

## üîß How to Add a Validator

1. Create a new file in `buddai/validators/` (e.g., `my_check.py`).
2. Inherit from `BaseValidator`.
3. Implement `validate(self, code, hardware, user_message)`.

```python
from .base_validator import BaseValidator

class MyCheckValidator(BaseValidator):
    name = "My Custom Check"
    
    def validate(self, code: str, hardware: str, user_message: str) -> list:
        issues = []
        if "forbidden_function" in code:
            issues.append({
                "severity": "error",
                "line": self.find_line(code, "forbidden_function"),
                "message": "Don't use forbidden_function!",
                "fix": lambda c: c.replace("forbidden_function", "allowed_function")
            })
        return issues
```

The `ValidatorRegistry` will automatically discover and load your new validator on the next restart.
