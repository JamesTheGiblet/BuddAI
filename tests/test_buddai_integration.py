#!/usr/bin/env python3
"""
Integration tests for BuddAI
Verifies end-to-end flow: Chat -> Generation -> Validation -> Auto-fix
"""
import unittest
from unittest.mock import MagicMock, patch
import sys
from pathlib import Path

# Setup path
REPO_ROOT = Path(__file__).parent.parent
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from buddai_executive import BuddAI

class TestBuddAIIntegration(unittest.TestCase):
    @patch('buddai_executive.OllamaClient')
    @patch('buddai_executive.StorageManager')
    @patch('buddai_executive.RepoManager')
    def setUp(self, MockRepo, MockStorage, MockOllama):
        with patch('builtins.print'):
            self.ai = BuddAI(user_id="test_integration", server_mode=True)
        self.ai.llm = MockOllama()
        self.ai.storage = MockStorage()
        
        # Ensure validators are loaded
        self.ai.validator = MagicMock(wraps=self.ai.validator)

    def test_end_to_end_validation_fix(self):
        """Test that bad code generated by LLM is caught and fixed"""
        # 1. Mock LLM returning bad code (using analogWrite on ESP32)
        self.ai.llm.query.return_value = "Here is code:\n```cpp\nvoid loop() { analogWrite(13, 100); }\n```"
        self.ai.hardware_profile.detect_hardware = MagicMock(return_value="ESP32-C3")
        
        # Prevent hardware profile from fixing it silently before validator
        self.ai.hardware_profile.apply_hardware_rules = MagicMock(side_effect=lambda code, *args: code)
        
        # 2. Run Chat
        response = self.ai.chat("dim the led")
        
        # 3. Verify Validator was called
        self.assertTrue(self.ai.validator.validate.called)
        
        # 4. Verify Auto-fix was applied (analogWrite -> ledcWrite)
        self.assertIn("ledcWrite", response)
        self.assertIn("Auto-corrected", response)

if __name__ == '__main__':
    unittest.main()